/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include "quexProcessed/lib/definitions"
 * (4) Lexical FSM class quexProcessed and its memento class.
 * (5) Constructor and init core of quexProcessed.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex 0.70.0.
 *
 * (C) 2005-2012 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef QUEX_INCLUDE_GUARD_quexProcessed__ANALYZER__GENERATED
#define QUEX_INCLUDE_GUARD_quexProcessed__ANALYZER__GENERATED

#include <cstddef>
#include "quexProcessed/lib/quex/compatibility/stdint.h"
#include "quexProcessed/quexProcessed-configuration"

#include "quexProcessed/lib/definitions"

/* Forward declarations ______________________________________________________*/
 
class quexProcessed_Memento;
class quexProcessed;    

typedef void  (*quexProcessed_AnalyzerFunctionP)(quexProcessed*);



class quexProcessed_Token;


/* User defined header content ________________________________________________
 * Must come before token class definition, since the token class 
 * might rely on contents of the header.                                     */

#   line 1 "quexExample.qx"

#include <cstdlib>  // for: atoi()

#   line 44 "quexProcessed/quexProcessed"



/* Declaration of all basic classes ___________________________________________
 *                                                                           */
#include "quexProcessed/lib/declarations"

/* Token class and token id definitions _______________________________________
 *                                                                           */
#include "quexProcessed/quexProcessed-token_ids"
 
extern const char* quexProcessed_map_token_id_to_name(const quexProcessed_token_id_t TokenID);
 
#include "quexProcessed/quexProcessed-token"

 

extern quexProcessed_Mode  quexProcessed_ONE_AND_ONLY;


extern  void quexProcessed_ONE_AND_ONLY_analyzer_function(quexProcessed* me);
#ifdef QUEX_OPTION_ASSERTS
extern  bool quexProcessed_ONE_AND_ONLY_has_base(const quexProcessed_Mode* mode);
#endif
#ifdef QUEX_OPTION_ASSERTS
extern  bool quexProcessed_ONE_AND_ONLY_has_entry_from(const quexProcessed_Mode* mode);
#endif
#ifdef QUEX_OPTION_ASSERTS
extern  bool quexProcessed_ONE_AND_ONLY_has_exit_to(const quexProcessed_Mode* mode);
#endif
extern  void quexProcessed_ONE_AND_ONLY_on_buffer_before_change(void* aux);
extern  void quexProcessed_ONE_AND_ONLY_on_buffer_overflow(void* aux);
extern  void quexProcessed_ONE_AND_ONLY_on_entry(quexProcessed* me, const quexProcessed_Mode* mode);
extern  void quexProcessed_ONE_AND_ONLY_on_exit(quexProcessed* me, const quexProcessed_Mode* mode);



typedef bool (*quexProcessed_callback_on_token_type)(quexProcessed_Token*);

class QUEX_quexProcessed_SETTING_USER_CLASS_DECLARATION_EPILOG_EXT quexProcessed_Memento {
public:
    quexProcessed_Memento()  {} /* Con- and Destruction necessary to trigger */
    ~quexProcessed_Memento() {} /* con- and destruction of user members.     */

    char*                             __input_name;
    quexProcessed_Buffer                 buffer;

    const struct quexProcessed_Mode_tag* __current_mode_p; 
    quexProcessed_AnalyzerFunctionP      current_analyzer_function;
           quexProcessed_Counter  counter;
    
    quexProcessed_Memento*               _parent_memento;

/* START: User's memento extentions __________________________________________*/

/* END: ______________________________________________________________________*/

#   if defined(QUEX_OPTION_ASSERTS)
    quexProcessed_AnalyzerFunctionP    DEBUG_analyzer_function_at_entry;
#   endif
};

class QUEX_quexProcessed_SETTING_USER_CLASS_DECLARATION_EPILOG_EXT quexProcessed {
public:
    /* __( Data Members )_______________________________________________________
     *                                                                        */
    quexProcessed_Buffer               buffer;
    quexProcessed_TokenQueue           _token_queue;  
    quexProcessed_ModeStack            _mode_stack;

    E_Error                         error_code;
    char*                           __input_name;

    const quexProcessed_Mode*          __current_mode_p; 
    /* Shortcut to current mode's analyzer function.                          */
    quexProcessed_AnalyzerFunctionP    current_analyzer_function;
#   if defined(QUEX_OPTION_ASSERTS)
    /* Backup of analyzer's function pointer => mode change detection.        */
    quexProcessed_AnalyzerFunctionP    DEBUG_analyzer_function_at_entry;
#   endif
           quexProcessed_Counter  counter;
    
    quexProcessed_Memento*                 _parent_memento;

public:
    typedef quexProcessed_Token      token_type;
    typedef quexProcessed_token_id_t   token_id_type;
    typedef quexProcessed_lexatom_t    char_type;

    /*__( Constructors )________________________________________________________
     *                                                                        */
    quexProcessed()
         { quexProcessed_MF_resources_absent_mark(this); error_code = E_Error_Uninitialized; }

    quexProcessed(const char*      Filename, 
                   quexProcessed_Converter* Converter = 0) 
         { quexProcessed_from_file_name(this, Filename, Converter); }

    quexProcessed(quexProcessed_ByteLoader*  byte_loader, 
                   quexProcessed_Converter*        Converter = 0) 
         { quexProcessed_from_ByteLoader(this, byte_loader, Converter); }

    quexProcessed(quexProcessed_lexatom_t* BufferMemoryBegin, 
                   size_t                  BufferMemorySize,
                   quexProcessed_lexatom_t*      BufferEndOfContentP = 0x0)
         { quexProcessed_from_memory(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    /* Named placement-new functions.                                         */
    static quexProcessed* from_file_name(const char*           Filename, 
                                               quexProcessed_Converter* Converter = 0) 
         { return new quexProcessed(Filename, Converter); }

    static quexProcessed* from_ByteLoader(quexProcessed_ByteLoader*  byte_loader, 
                                                quexProcessed_Converter*   Converter = 0) 
         { return new quexProcessed(byte_loader, Converter); }

    static quexProcessed* from_memory(quexProcessed_lexatom_t* BufferMemoryBegin, 
                                            size_t             BufferMemorySize,
                                            quexProcessed_lexatom_t* BufferEndOfContentP = 0x0)
         { return new quexProcessed(BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    virtual ~quexProcessed()
         { quexProcessed_destruct(this); }
public:
    /*__( Reset )_______________________________________________________________
     *                                                                        */
    bool reset() { return quexProcessed_MF_reset(this); }
    bool reset_file_name(const char* FileName, quexProcessed_Converter* Converter = 0) { return quexProcessed_MF_reset_file_name(this, FileName, Converter); }
    bool reset_ByteLoader(quexProcessed_ByteLoader* byte_loader, quexProcessed_Converter* Converter = 0) { return quexProcessed_MF_reset_ByteLoader(this, byte_loader, Converter); }
    bool reset_memory(quexProcessed_lexatom_t* BufferMemoryBegin, size_t BufferMemorySize, quexProcessed_lexatom_t* BufferEndOfContentP) { return quexProcessed_MF_reset_memory(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    /*__( Include From and To Substream )_______________________________________
     *                                                                        */
    bool include_push_file_name(const char* FileName, quexProcessed_Converter* Converter = 0) { return quexProcessed_MF_include_push_file_name(this, FileName, Converter); }
    bool include_push_ByteLoader(const char* InputName, quexProcessed_ByteLoader* byte_loader, quexProcessed_Converter* Converter) { return quexProcessed_MF_include_push_ByteLoader(this, InputName, byte_loader, Converter); }
    bool include_push_memory(const char* InputName, quexProcessed_lexatom_t* BufferMemoryBegin, size_t BufferMemorySize, quexProcessed_lexatom_t* BufferEndOfContentP) { return quexProcessed_MF_include_push_memory(this, InputName, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }
    bool include_pop() { return quexProcessed_MF_include_pop(this); }
    void include_stack_delete() { quexProcessed_MF_include_stack_delete(this); }
    bool include_detect_recursion(const char* InputName) { return quexProcessed_MF_include_detect_recursion(this, InputName); }

    /*__( Receiving Tokens -- from outside lexer )_____________________________
     *                                                                       */
    bool run(quexProcessed_callback_on_token_type on_token, bool ErrorPrintF) { return quexProcessed_MF_run(this, on_token, ErrorPrintF); }
    void receive(quexProcessed_Token** token_pp) { quexProcessed_MF_receive(this, token_pp); }

    /*__( Sending Tokens -- from inside lexer )________________________________
     *                                                                       */
    quexProcessed_Token* token_p() { return quexProcessed_MF_token_p(this); }

    void send(quexProcessed_token_id_t Id) { quexProcessed_MF_send(this, Id); }
    void send_n(quexProcessed_token_id_t Id, size_t RepetitionN) { quexProcessed_MF_send_n(this, Id, RepetitionN); }
    bool send_text(quexProcessed_token_id_t Id, quexProcessed_lexatom_t* BeginP, quexProcessed_lexatom_t* EndP) { return quexProcessed_MF_send_text(this, Id, BeginP, EndP); }
    bool send_string(quexProcessed_token_id_t Id, quexProcessed_lexatom_t* ZeroTerminatedString) { return quexProcessed_MF_send_string(this, Id, ZeroTerminatedString); }

    /*__( Mode Handling )______________________________________________________
     *                                                                       */
    const quexProcessed_Mode* mode() { return quexProcessed_MF_mode(this); }
    void set_mode_brutally(const quexProcessed_Mode* Mode) { quexProcessed_MF_set_mode_brutally(this, Mode); }
    void enter_mode(const quexProcessed_Mode* TargetMode) { quexProcessed_MF_enter_mode(this, TargetMode); }

    void pop_mode() { quexProcessed_MF_pop_mode(this); }
    void pop_drop_mode() { quexProcessed_MF_pop_drop_mode(this); }
    void push_mode(quexProcessed_Mode* new_mode) { quexProcessed_MF_push_mode(this, new_mode); }

    /*__( Line/Column Counter )________________________________________________
     *                                                                       */
    size_t line_number() { return quexProcessed_MF_line_number(this); }
    size_t line_number_at_begin() { return quexProcessed_MF_line_number_at_begin(this); }
    size_t line_number_at_end() { return quexProcessed_MF_line_number_at_end(this); }
    void line_number_set(size_t Y) { quexProcessed_MF_line_number_set(this, Y); }

    size_t column_number() { return quexProcessed_MF_column_number(this); }
    size_t column_number_at_begin() { return quexProcessed_MF_column_number_at_begin(this); }
    size_t column_number_at_end() { return quexProcessed_MF_column_number_at_end(this); }
    void column_number_set(size_t X) { quexProcessed_MF_column_number_set(this, X); }

    /*__( Indentation )________________________________________________________
     *                                                                       */
    

public:
    /*__( General Information )________________________________________________
     *                                                                       */
    const char* version() { return quexProcessed_MF_version(this); }
    void print_this() { quexProcessed_MF_print_this(this); }
    const char* input_name() { return quexProcessed_MF_input_name(this); }
    bool input_name_set(const char* InputName) { return quexProcessed_MF_input_name_set(this, InputName); }

    /*__( Navigation: Tell/Seek )______________________________________________
     *                                                                       */
    size_t tell() { return quexProcessed_MF_tell(this); }
    void seek(const size_t CharacterIndex) { quexProcessed_MF_seek(this, CharacterIndex); }
    void seek_forward(const size_t CharacterN) { quexProcessed_MF_seek_forward(this, CharacterN); }
    void seek_backward(const size_t CharacterN) { quexProcessed_MF_seek_backward(this, CharacterN); }
                
    void undo() { quexProcessed_MF_undo(this); }
    void undo_n(size_t DeltaN_Backward) { quexProcessed_MF_undo_n(this, DeltaN_Backward); }

    /*__( Byte Order Reversion Activation / Deactivation )_____________________
     *                                                                       */
    bool byte_order_reversion() { return quexProcessed_MF_byte_order_reversion(this); }
    void byte_order_reversion_set(bool Value) { quexProcessed_MF_byte_order_reversion_set(this, Value); }

    /*__( Error Codes )________________________________________________________
     *                                                                       */
    void error_code_clear() { quexProcessed_MF_error_code_clear(this); }
    bool error_code_is_void() { return quexProcessed_MF_error_code_is_void(this); }
    void error_code_set_void() { quexProcessed_MF_error_code_set_void(this); }
    void error_code_set_if_first(E_Error ErrorCode) { quexProcessed_MF_error_code_set_if_first(this, ErrorCode); }

    /*__( Deep Resources )_____________________________________________________
     *                                                                       */
    void collect_user_memory(quexProcessed_lexatom_t** user_memory_p) { quexProcessed_MF_collect_user_memory(this, user_memory_p); }
    void resources_absent_mark() { quexProcessed_MF_resources_absent_mark(this); }
    bool resources_absent() { return quexProcessed_MF_resources_absent(this); }

#define self  (*(quexProcessed*)this)
/* START: User's class body extensions _______________________________________*/

/* END: ______________________________________________________________________*/
#undef  self

public:
    /* Befriend all modes                                                     */
    friend  void quexProcessed_ONE_AND_ONLY_analyzer_function(quexProcessed* me);
#ifdef QUEX_OPTION_ASSERTS
    friend  bool quexProcessed_ONE_AND_ONLY_has_base(const quexProcessed_Mode* mode);
#endif
#ifdef QUEX_OPTION_ASSERTS
    friend  bool quexProcessed_ONE_AND_ONLY_has_entry_from(const quexProcessed_Mode* mode);
#endif
#ifdef QUEX_OPTION_ASSERTS
    friend  bool quexProcessed_ONE_AND_ONLY_has_exit_to(const quexProcessed_Mode* mode);
#endif
    friend  void quexProcessed_ONE_AND_ONLY_on_buffer_before_change(void* aux);
    friend  void quexProcessed_ONE_AND_ONLY_on_buffer_overflow(void* aux);
    friend  void quexProcessed_ONE_AND_ONLY_on_entry(quexProcessed* me, const quexProcessed_Mode* mode);
    friend  void quexProcessed_ONE_AND_ONLY_on_exit(quexProcessed* me, const quexProcessed_Mode* mode);

  
private:
    quexProcessed(const quexProcessed&);                   /* Forbidden */
    quexProcessed& operator=(const quexProcessed& Other); /* Forbidden */

};





#include "quexProcessed/lib/implementations-inline.i"

/* START: User defined header content _________________________________________
 *        The 'footer' content relies on class definitions made above.        */



#endif /* QUEX_INCLUDE_GUARD_quexProcessed__ANALYZER__GENERATED */