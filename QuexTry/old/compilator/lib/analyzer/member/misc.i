/* -*- C++ -*-   vim: set syntax=cpp:
 * (C) Frankt-Rene Schaefer
 * ABSOLUTELY NO WARRANTY               */
#ifndef QUEX_INCLUDE_GUARD_compilator__ANALYZER__MEMBER__MISC_I
#define QUEX_INCLUDE_GUARD_compilator__ANALYZER__MEMBER__MISC_I

#include "compilator\lib\analyzer/Counter"
#include "compilator\lib\buffer/Buffer_print"
#include "compilator\lib\buffer/lexatoms/LexatomLoader"
#include "compilator\lib\lexeme/basics"





inline void 
compilator_MF_error_code_clear(compilator* me)
{ me->error_code = E_Error_None; }

inline void 
compilator_MF_error_code_set_void(compilator* me)
{ me->error_code = E_Error_Uninitialized; }

inline bool 
compilator_MF_error_code_is_void(compilator* me)
{ return me->error_code == E_Error_Uninitialized; }

inline void 
compilator_MF_error_code_set_if_first(compilator* me, E_Error ErrorCode)
/* Never overwrite an error code
 * => original error is maintained.                                           */
{ if( me->error_code == E_Error_None ) me->error_code = ErrorCode; }

inline compilator_Token*  
compilator_MF_token_p(compilator* me)
{
    return me->_token_queue.write_iterator; 
}

inline void 
compilator_MF_send(compilator* me, 
                   compilator_token_id_t  Id)
{ compilator_TokenQueue_push(&me->_token_queue, Id); }

inline void 
compilator_MF_send_n(compilator* me, 
                     compilator_token_id_t  Id, 
                     size_t              RepetitionN)
{ compilator_TokenQueue_push_repeated(&me->_token_queue, Id, RepetitionN); }

inline bool 
compilator_MF_send_text(compilator* me, 
                        compilator_token_id_t  Id,
                        compilator_lexatom_t*  BeginP, 
                        compilator_lexatom_t*  EndP)
{ return compilator_TokenQueue_push_text(&me->_token_queue, Id, BeginP, EndP); }

inline bool 
compilator_MF_send_string(compilator* me,
                          compilator_token_id_t  Id,
                          compilator_lexatom_t*  ZeroTerminatedString)
{ 
    const size_t Length = compilator_lexeme_length((const compilator_lexatom_t*)ZeroTerminatedString);

    return compilator_TokenQueue_push_text(&me->_token_queue, Id, ZeroTerminatedString, 
                                           ZeroTerminatedString + (ptrdiff_t)Length + 1); 
}

inline bool
compilator_MF_byte_order_reversion(compilator* me)
{ 
    __quex_assert(0 != me->buffer.filler);
    return me->buffer.filler->_byte_order_reversion_active_f; 
}

inline void     
compilator_MF_byte_order_reversion_set(compilator* me, bool Value)
{ 
    __quex_assert(0 != me->buffer.filler);
    me->buffer.filler->_byte_order_reversion_active_f = Value; 
}

inline const char*
compilator_MF_input_name(compilator* me)
{ return me->__input_name; }

inline bool
compilator_MF_input_name_set(compilator* me, const char* InputNameP)
/* Sets the 'input name', i.e. some string that identifies the input stream.
 * In case of failure '.__input_name' is set to NULL.
 *
 * RETURNS: true, for success. false, else.                                   */
{ 
    if( me->__input_name ) {
        quex::MemoryManager_free(me->__input_name, E_MemoryObjectType_INPUT_NAME);
    }
    if(  ! InputNameP ) {
        me->__input_name = (char*)0;
        return true;
    }
    else {
        me->__input_name = quex::MemoryManager_clone_string(InputNameP);
        return me->__input_name ? true : false;
    }
}

inline const char* 
compilator_MF_version(compilator* me)
{ 
    (void)me;
    return          QUEX_STRING(compilator)           \
           ": Version "         QUEX_compilator_SETTING_ANALYZER_VERSION \
           ". Date "            QUEX_compilator_SETTING_BUILD_DATE       \
           "Generated by Quex " QUEX_compilator_SETTING_VERSION ".";
}

inline void
compilator_MF_print_this(compilator* me)
{
    const char*       handler_name = (const char*)0;

    QUEX_DEBUG_PRINT1("  mode:       %s;\n", 
                      me->__current_mode_p == 0x0 ? "0x0" : me->__current_mode_p->name);
    QUEX_DEBUG_PRINT1("  error_code: %s;\n", E_Error_NAME(me->error_code));

    if( me->error_code != E_Error_None ) {
        handler_name = E_Error_MISSING_HANDLER_NAME(me->error_code);
        if( handler_name ) {
            QUEX_DEBUG_PRINT1("              (* '%s' has not been specified for mode*)\n", 
                              handler_name);
        }
    }

     compilator_Counter_print_this(&me->counter);
    

    QUEX_DEBUG_PRINT("  _mode_stack: ");
    compilator_ModeStack_print(&me->_mode_stack);

    compilator_Buffer_print_this(&me->buffer);

    compilator_user_print(me);

    if( me->error_code != E_Error_None ) {
        compilator_Buffer_print_content_detailed(&me->buffer);
        QUEX_DEBUG_PRINT("\n\n");
    }
}


inline size_t compilator_MF_line_number(const compilator* me)            { return compilator_MF_line_number_at_begin(me); }
inline size_t compilator_MF_line_number_at_begin(const compilator* me)   { return me->counter._line_number_at_begin; }
inline size_t compilator_MF_line_number_at_end(const compilator* me)     { return me->counter._line_number_at_end; }
inline void   compilator_MF_line_number_set(compilator* me, size_t Value) { me->counter._line_number_at_end = Value; }


inline size_t compilator_MF_column_number(const compilator* me)          { return compilator_MF_column_number_at_begin(me); }
inline size_t compilator_MF_column_number_at_begin(const compilator* me) { return me->counter._column_number_at_begin; }
inline size_t compilator_MF_column_number_at_end(const compilator* me)   { return me->counter._column_number_at_end; }
inline void   compilator_MF_column_number_set(compilator* me, size_t Value) { me->counter._column_number_at_end = Value; }







#endif /* QUEX_INCLUDE_GUARD_compilator__ANALYZER__MEMBER__MISC_I */
