/* -*- C++ -*-   vim: set syntax=cpp:
 * (C) Frankt-Rene Schaefer
 * ABSOLUTELY NO WARRANTY               */
#ifndef QUEX_INCLUDE_GUARD_Calc_lexer__ANALYZER__MEMBER__MISC_I
#define QUEX_INCLUDE_GUARD_Calc_lexer__ANALYZER__MEMBER__MISC_I

#include "lexical_analysis/lib/analyzer/Counter"
#include "lexical_analysis/lib/buffer/Buffer_print"
#include "lexical_analysis/lib/buffer/lexatoms/LexatomLoader"
#include "lexical_analysis/lib/lexeme/basics"





 void 
Calc_lexer_MF_error_code_clear(struct Calc_lexer_tag* me)
{ me->error_code = E_Error_None; }

 void 
Calc_lexer_MF_error_code_set_void(struct Calc_lexer_tag* me)
{ me->error_code = E_Error_Uninitialized; }

 bool 
Calc_lexer_MF_error_code_is_void(struct Calc_lexer_tag* me)
{ return me->error_code == E_Error_Uninitialized; }

 void 
Calc_lexer_MF_error_code_set_if_first(struct Calc_lexer_tag* me, E_Error ErrorCode)
/* Never overwrite an error code
 * => original error is maintained.                                           */
{ if( me->error_code == E_Error_None ) me->error_code = ErrorCode; }

 struct Calc_lexer_Token_tag*  
Calc_lexer_MF_token_p(struct Calc_lexer_tag* me)
{
    return me->_token_queue.write_iterator; 
}

 void 
Calc_lexer_MF_send(struct Calc_lexer_tag* me, 
                   Calc_lexer_token_id_t  Id)
{ Calc_lexer_TokenQueue_push(&me->_token_queue, Id); }

 void 
Calc_lexer_MF_send_n(struct Calc_lexer_tag* me, 
                     Calc_lexer_token_id_t  Id, 
                     size_t              RepetitionN)
{ Calc_lexer_TokenQueue_push_repeated(&me->_token_queue, Id, RepetitionN); }

 bool 
Calc_lexer_MF_send_text(struct Calc_lexer_tag* me, 
                        Calc_lexer_token_id_t  Id,
                        Calc_lexer_lexatom_t*  BeginP, 
                        Calc_lexer_lexatom_t*  EndP)
{ return Calc_lexer_TokenQueue_push_text(&me->_token_queue, Id, BeginP, EndP); }

 bool 
Calc_lexer_MF_send_string(struct Calc_lexer_tag* me,
                          Calc_lexer_token_id_t  Id,
                          Calc_lexer_lexatom_t*  ZeroTerminatedString)
{ 
    const size_t Length = Calc_lexer_lexeme_length((const Calc_lexer_lexatom_t*)ZeroTerminatedString);

    return Calc_lexer_TokenQueue_push_text(&me->_token_queue, Id, ZeroTerminatedString, 
                                           ZeroTerminatedString + (ptrdiff_t)Length + 1); 
}

 bool
Calc_lexer_MF_byte_order_reversion(struct Calc_lexer_tag* me)
{ 
    __quex_assert(0 != me->buffer.filler);
    return me->buffer.filler->_byte_order_reversion_active_f; 
}

 void     
Calc_lexer_MF_byte_order_reversion_set(struct Calc_lexer_tag* me, bool Value)
{ 
    __quex_assert(0 != me->buffer.filler);
    me->buffer.filler->_byte_order_reversion_active_f = Value; 
}

 const char*
Calc_lexer_MF_input_name(struct Calc_lexer_tag* me)
{ return me->__input_name; }

 bool
Calc_lexer_MF_input_name_set(struct Calc_lexer_tag* me, const char* InputNameP)
/* Sets the 'input name', i.e. some string that identifies the input stream.
 * In case of failure '.__input_name' is set to NULL.
 *
 * RETURNS: true, for success. false, else.                                   */
{ 
    if( me->__input_name ) {
        quex_MemoryManager_free(me->__input_name, E_MemoryObjectType_INPUT_NAME);
    }
    if(  ! InputNameP ) {
        me->__input_name = (char*)0;
        return true;
    }
    else {
        me->__input_name = quex_MemoryManager_clone_string(InputNameP);
        return me->__input_name ? true : false;
    }
}

 const char* 
Calc_lexer_MF_version(struct Calc_lexer_tag* me)
{ 
    (void)me;
    return          QUEX_STRING(struct Calc_lexer_tag)           \
           ": Version "         QUEX_Calc_lexer_SETTING_ANALYZER_VERSION \
           ". Date "            QUEX_Calc_lexer_SETTING_BUILD_DATE       \
           "Generated by Quex " QUEX_Calc_lexer_SETTING_VERSION ".";
}

 void
Calc_lexer_MF_print_this(struct Calc_lexer_tag* me)
{
    const char*       handler_name = (const char*)0;

    QUEX_DEBUG_PRINT1("  mode:       %s;\n", 
                      me->__current_mode_p == 0x0 ? "0x0" : me->__current_mode_p->name);
    QUEX_DEBUG_PRINT1("  error_code: %s;\n", E_Error_NAME(me->error_code));

    if( me->error_code != E_Error_None ) {
        handler_name = E_Error_MISSING_HANDLER_NAME(me->error_code);
        if( handler_name ) {
            QUEX_DEBUG_PRINT1("              (* '%s' has not been specified for mode*)\n", 
                              handler_name);
        }
    }

     Calc_lexer_Counter_print_this(&me->counter);
    

    QUEX_DEBUG_PRINT("  _mode_stack: ");
    Calc_lexer_ModeStack_print(&me->_mode_stack);

    Calc_lexer_Buffer_print_this(&me->buffer);

    Calc_lexer_user_print(me);

    if( me->error_code != E_Error_None ) {
        Calc_lexer_Buffer_print_content_detailed(&me->buffer);
        QUEX_DEBUG_PRINT("\n\n");
    }
}


 size_t Calc_lexer_MF_line_number(const struct Calc_lexer_tag* me)            { return Calc_lexer_MF_line_number_at_begin(me); }
 size_t Calc_lexer_MF_line_number_at_begin(const struct Calc_lexer_tag* me)   { return me->counter._line_number_at_begin; }
 size_t Calc_lexer_MF_line_number_at_end(const struct Calc_lexer_tag* me)     { return me->counter._line_number_at_end; }
 void   Calc_lexer_MF_line_number_set(struct Calc_lexer_tag* me, size_t Value) { me->counter._line_number_at_end = Value; }


 size_t Calc_lexer_MF_column_number(const struct Calc_lexer_tag* me)          { return Calc_lexer_MF_column_number_at_begin(me); }
 size_t Calc_lexer_MF_column_number_at_begin(const struct Calc_lexer_tag* me) { return me->counter._column_number_at_begin; }
 size_t Calc_lexer_MF_column_number_at_end(const struct Calc_lexer_tag* me)   { return me->counter._column_number_at_end; }
 void   Calc_lexer_MF_column_number_set(struct Calc_lexer_tag* me, size_t Value) { me->counter._column_number_at_end = Value; }







#endif /* QUEX_INCLUDE_GUARD_Calc_lexer__ANALYZER__MEMBER__MISC_I */
