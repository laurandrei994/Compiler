/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include "compilator\lib\definitions"
 * (4) Lexical FSM class compilator and its memento class.
 * (5) Constructor and init core of compilator.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex 0.69.3.
 *
 * (C) 2005-2012 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef QUEX_INCLUDE_GUARD_compilator__ANALYZER__GENERATED
#define QUEX_INCLUDE_GUARD_compilator__ANALYZER__GENERATED

#include <cstddef>
#include "compilator\lib\quex/compatibility/stdint.h"
#include "compilator\compilator-configuration"

#include "compilator\lib\definitions"

/* Forward declarations ______________________________________________________*/
 
class compilator_Memento;
class compilator;    

typedef void  (*compilator_AnalyzerFunctionP)(compilator*);



class compilator_Token;


/* User defined header content ________________________________________________
 * Must come before token class definition, since the token class 
 * might rely on contents of the header.                                     */



/* Declaration of all basic classes ___________________________________________
 *                                                                           */
#include "compilator\lib\declarations"

/* Token class and token id definitions _______________________________________
 *                                                                           */
#include "compilator\compilator-token_ids"
 
extern const char* compilator_map_token_id_to_name(const compilator_token_id_t TokenID);
 
#include "compilator\compilator-token"

 

extern compilator_Mode  compilator_PROGRAM;


extern  void compilator_PROGRAM_analyzer_function(compilator* me);
#ifdef QUEX_OPTION_ASSERTS
extern  bool compilator_PROGRAM_has_base(const compilator_Mode* mode);
#endif
#ifdef QUEX_OPTION_ASSERTS
extern  bool compilator_PROGRAM_has_entry_from(const compilator_Mode* mode);
#endif
#ifdef QUEX_OPTION_ASSERTS
extern  bool compilator_PROGRAM_has_exit_to(const compilator_Mode* mode);
#endif
extern  void compilator_PROGRAM_on_buffer_before_change(void* aux);
extern  void compilator_PROGRAM_on_buffer_overflow(void* aux);
extern  void compilator_PROGRAM_on_entry(compilator* me, const compilator_Mode* mode);
extern  void compilator_PROGRAM_on_exit(compilator* me, const compilator_Mode* mode);



typedef bool (*compilator_callback_on_token_type)(compilator_Token*);

class QUEX_compilator_SETTING_USER_CLASS_DECLARATION_EPILOG_EXT compilator_Memento {
public:
    compilator_Memento()  {} /* Con- and Destruction necessary to trigger */
    ~compilator_Memento() {} /* con- and destruction of user members.     */

    char*                             __input_name;
    compilator_Buffer                 buffer;

    const struct compilator_Mode_tag* __current_mode_p; 
    compilator_AnalyzerFunctionP      current_analyzer_function;
           compilator_Counter  counter;
    
    compilator_Memento*               _parent_memento;

/* START: User's memento extentions __________________________________________*/

/* END: ______________________________________________________________________*/

#   if defined(QUEX_OPTION_ASSERTS)
    compilator_AnalyzerFunctionP    DEBUG_analyzer_function_at_entry;
#   endif
};

class QUEX_compilator_SETTING_USER_CLASS_DECLARATION_EPILOG_EXT compilator {
public:
    /* __( Data Members )_______________________________________________________
     *                                                                        */
    compilator_Buffer               buffer;
    compilator_TokenQueue           _token_queue;  
    compilator_ModeStack            _mode_stack;

    E_Error                         error_code;
    char*                           __input_name;

    const compilator_Mode*          __current_mode_p; 
    /* Shortcut to current mode's analyzer function.                          */
    compilator_AnalyzerFunctionP    current_analyzer_function;
#   if defined(QUEX_OPTION_ASSERTS)
    /* Backup of analyzer's function pointer => mode change detection.        */
    compilator_AnalyzerFunctionP    DEBUG_analyzer_function_at_entry;
#   endif
           compilator_Counter  counter;
    
    compilator_Memento*                 _parent_memento;

public:
    typedef compilator_Token      token_type;
    typedef compilator_token_id_t   token_id_type;
    typedef compilator_lexatom_t    char_type;

    /*__( Constructors )________________________________________________________
     *                                                                        */
    compilator()
         { compilator_MF_resources_absent_mark(this); error_code = E_Error_Uninitialized; }

    compilator(const char*      Filename, 
                compilator_Converter* Converter = 0) 
         { compilator_from_file_name(this, Filename, Converter); }

    compilator(compilator_ByteLoader*  byte_loader, 
                compilator_Converter*        Converter = 0) 
         { compilator_from_ByteLoader(this, byte_loader, Converter); }

    compilator(compilator_lexatom_t* BufferMemoryBegin, 
                size_t                  BufferMemorySize,
                compilator_lexatom_t*      BufferEndOfContentP = 0x0)
         { compilator_from_memory(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    /* Named placement-new functions.                                         */
    static compilator* from_file_name(const char*           Filename, 
                                            compilator_Converter* Converter = 0) 
         { return new compilator(Filename, Converter); }

    static compilator* from_ByteLoader(compilator_ByteLoader*  byte_loader, 
                                             compilator_Converter*   Converter = 0) 
         { return new compilator(byte_loader, Converter); }

    static compilator* from_memory(compilator_lexatom_t* BufferMemoryBegin, 
                                         size_t             BufferMemorySize,
                                         compilator_lexatom_t* BufferEndOfContentP = 0x0)
         { return new compilator(BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    virtual ~compilator()
         { compilator_destruct(this); }
public:
    /*__( Reset )_______________________________________________________________
     *                                                                        */
    bool reset() { return compilator_MF_reset(this); }
    bool reset_file_name(const char* FileName, compilator_Converter* Converter = 0) { return compilator_MF_reset_file_name(this, FileName, Converter); }
    bool reset_ByteLoader(compilator_ByteLoader* byte_loader, compilator_Converter* Converter = 0) { return compilator_MF_reset_ByteLoader(this, byte_loader, Converter); }
    bool reset_memory(compilator_lexatom_t* BufferMemoryBegin, size_t BufferMemorySize, compilator_lexatom_t* BufferEndOfContentP) { return compilator_MF_reset_memory(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    /*__( Include From and To Substream )_______________________________________
     *                                                                        */
    bool include_push_file_name(const char* FileName, compilator_Converter* Converter = 0) { return compilator_MF_include_push_file_name(this, FileName, Converter); }
    bool include_push_ByteLoader(const char* InputName, compilator_ByteLoader* byte_loader, compilator_Converter* Converter) { return compilator_MF_include_push_ByteLoader(this, InputName, byte_loader, Converter); }
    bool include_push_memory(const char* InputName, compilator_lexatom_t* BufferMemoryBegin, size_t BufferMemorySize, compilator_lexatom_t* BufferEndOfContentP) { return compilator_MF_include_push_memory(this, InputName, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }
    bool include_pop() { return compilator_MF_include_pop(this); }
    void include_stack_delete() { compilator_MF_include_stack_delete(this); }
    bool include_detect_recursion(const char* InputName) { return compilator_MF_include_detect_recursion(this, InputName); }

    /*__( Receiving Tokens -- from outside lexer )_____________________________
     *                                                                       */
    bool run(compilator_callback_on_token_type on_token, bool ErrorPrintF) { return compilator_MF_run(this, on_token, ErrorPrintF); }
    void receive(compilator_Token** token_pp) { compilator_MF_receive(this, token_pp); }

    /*__( Sending Tokens -- from inside lexer )________________________________
     *                                                                       */
    compilator_Token* token_p() { return compilator_MF_token_p(this); }

    void send(compilator_token_id_t Id) { compilator_MF_send(this, Id); }
    void send_n(compilator_token_id_t Id, size_t RepetitionN) { compilator_MF_send_n(this, Id, RepetitionN); }
    bool send_text(compilator_token_id_t Id, compilator_lexatom_t* BeginP, compilator_lexatom_t* EndP) { return compilator_MF_send_text(this, Id, BeginP, EndP); }
    bool send_string(compilator_token_id_t Id, compilator_lexatom_t* ZeroTerminatedString) { return compilator_MF_send_string(this, Id, ZeroTerminatedString); }

    /*__( Mode Handling )______________________________________________________
     *                                                                       */
    const compilator_Mode* mode() { return compilator_MF_mode(this); }
    void set_mode_brutally(const compilator_Mode* Mode) { compilator_MF_set_mode_brutally(this, Mode); }
    void enter_mode(const compilator_Mode* TargetMode) { compilator_MF_enter_mode(this, TargetMode); }

    void pop_mode() { compilator_MF_pop_mode(this); }
    void pop_drop_mode() { compilator_MF_pop_drop_mode(this); }
    void push_mode(compilator_Mode* new_mode) { compilator_MF_push_mode(this, new_mode); }

    /*__( Line/Column Counter )________________________________________________
     *                                                                       */
    size_t line_number() { return compilator_MF_line_number(this); }
    size_t line_number_at_begin() { return compilator_MF_line_number_at_begin(this); }
    size_t line_number_at_end() { return compilator_MF_line_number_at_end(this); }
    void line_number_set(size_t Y) { compilator_MF_line_number_set(this, Y); }

    size_t column_number() { return compilator_MF_column_number(this); }
    size_t column_number_at_begin() { return compilator_MF_column_number_at_begin(this); }
    size_t column_number_at_end() { return compilator_MF_column_number_at_end(this); }
    void column_number_set(size_t X) { compilator_MF_column_number_set(this, X); }

    /*__( Indentation )________________________________________________________
     *                                                                       */
    

public:
    /*__( General Information )________________________________________________
     *                                                                       */
    const char* version() { return compilator_MF_version(this); }
    void print_this() { compilator_MF_print_this(this); }
    const char* input_name() { return compilator_MF_input_name(this); }
    bool input_name_set(const char* InputName) { return compilator_MF_input_name_set(this, InputName); }

    /*__( Navigation: Tell/Seek )______________________________________________
     *                                                                       */
    size_t tell() { return compilator_MF_tell(this); }
    void seek(const size_t CharacterIndex) { compilator_MF_seek(this, CharacterIndex); }
    void seek_forward(const size_t CharacterN) { compilator_MF_seek_forward(this, CharacterN); }
    void seek_backward(const size_t CharacterN) { compilator_MF_seek_backward(this, CharacterN); }
                
    void undo() { compilator_MF_undo(this); }
    void undo_n(size_t DeltaN_Backward) { compilator_MF_undo_n(this, DeltaN_Backward); }

    /*__( Byte Order Reversion Activation / Deactivation )_____________________
     *                                                                       */
    bool byte_order_reversion() { return compilator_MF_byte_order_reversion(this); }
    void byte_order_reversion_set(bool Value) { compilator_MF_byte_order_reversion_set(this, Value); }

    /*__( Error Codes )________________________________________________________
     *                                                                       */
    void error_code_clear() { compilator_MF_error_code_clear(this); }
    bool error_code_is_void() { return compilator_MF_error_code_is_void(this); }
    void error_code_set_void() { compilator_MF_error_code_set_void(this); }
    void error_code_set_if_first(E_Error ErrorCode) { compilator_MF_error_code_set_if_first(this, ErrorCode); }

    /*__( Deep Resources )_____________________________________________________
     *                                                                       */
    void collect_user_memory(compilator_lexatom_t** user_memory_p) { compilator_MF_collect_user_memory(this, user_memory_p); }
    void resources_absent_mark() { compilator_MF_resources_absent_mark(this); }
    bool resources_absent() { return compilator_MF_resources_absent(this); }

#define self  (*(compilator*)this)
/* START: User's class body extensions _______________________________________*/

/* END: ______________________________________________________________________*/
#undef  self

public:
    /* Befriend all modes                                                     */
    friend  void compilator_PROGRAM_analyzer_function(compilator* me);
#ifdef QUEX_OPTION_ASSERTS
    friend  bool compilator_PROGRAM_has_base(const compilator_Mode* mode);
#endif
#ifdef QUEX_OPTION_ASSERTS
    friend  bool compilator_PROGRAM_has_entry_from(const compilator_Mode* mode);
#endif
#ifdef QUEX_OPTION_ASSERTS
    friend  bool compilator_PROGRAM_has_exit_to(const compilator_Mode* mode);
#endif
    friend  void compilator_PROGRAM_on_buffer_before_change(void* aux);
    friend  void compilator_PROGRAM_on_buffer_overflow(void* aux);
    friend  void compilator_PROGRAM_on_entry(compilator* me, const compilator_Mode* mode);
    friend  void compilator_PROGRAM_on_exit(compilator* me, const compilator_Mode* mode);

  
private:
    compilator(const compilator&);                   /* Forbidden */
    compilator& operator=(const compilator& Other); /* Forbidden */

};





#include "compilator\lib\implementations-inline.i"

/* START: User defined header content _________________________________________
 *        The 'footer' content relies on class definitions made above.        */



#endif /* QUEX_INCLUDE_GUARD_compilator__ANALYZER__GENERATED */